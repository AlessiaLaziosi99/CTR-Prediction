<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alessia Laziosi">

<title>PAC project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Alessia Laziosi - PAC project_files/libs/clipboard/clipboard.min.js"></script>
<script src="Alessia Laziosi - PAC project_files/libs/quarto-html/quarto.js"></script>
<script src="Alessia Laziosi - PAC project_files/libs/quarto-html/popper.min.js"></script>
<script src="Alessia Laziosi - PAC project_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Alessia Laziosi - PAC project_files/libs/quarto-html/anchor.min.js"></script>
<link href="Alessia Laziosi - PAC project_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Alessia Laziosi - PAC project_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Alessia Laziosi - PAC project_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Alessia Laziosi - PAC project_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Alessia Laziosi - PAC project_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">PAC project</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Alessia Laziosi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This report summarizes the analysis performed on a dataset containing 4,000 observations. The objective was to develop a regression model to predict the click-through rate (CTR), defined as the percentage of visitors who click on a given advertisement intended to drive traffic. The primary goal was to minimize the Root Mean Squared Error (RMSE) of the predictions. The approach followed a data analysis process involved thorough data cleaning, exploratory data analysis,variable selection, and the application of different modeling techniques. Throughout the modeling phase, multiple strategies were tested to improve the RMSE while carefully monitoring and attempting to mitigate the risk of overfitting.</p>
</section>
<section id="data-preparation-and-initial-data-exploration" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation-and-initial-data-exploration">Data Preparation and initial data exploration</h2>
<section id="loading-and-overview-of-data" class="level3">
<h3 class="anchored" data-anchor-id="loading-and-overview-of-data">Loading and Overview of Data</h3>
<p>There were two different data sets to be loaded:</p>
<ul>
<li><p>analysis_data is the “train” set, containing 4000 observations of 29 variables.</p></li>
<li><p>scoring_data is the “test” set, containing 1000 observations of 28 variables.</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">setwd</span>(<span class="st">"C:</span><span class="sc">\\</span><span class="st">Users</span><span class="sc">\\</span><span class="st">huawei</span><span class="sc">\\</span><span class="st">Desktop</span><span class="sc">\\</span><span class="st">APAN FRAMEWORK</span><span class="sc">\\</span><span class="st">my_PAC_project</span><span class="sc">\\</span><span class="st">Data"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getwd</span>()       </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">list.files</span>()  </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>analysis_data <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"analysis_data.csv"</span>, <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>scoring_data  <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"scoring_data.csv"</span>, <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="initial-overview-of-data" class="level3">
<h3 class="anchored" data-anchor-id="initial-overview-of-data">Initial Overview of Data</h3>
<p>I utilized the skimr package to summarize data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(skimr)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">skim</span>(analysis_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>I identified 8 categorical and 21 numerical predictors, with numerous missing values that needed to be imputed before proceeding:</p>
<ul>
<li><p>Six variables had 237 missing values each</p></li>
<li><p>Twelve variables had 197 missing values each.</p></li>
</ul>
<p>CTR was a continuous variable. CTR, as well as the variables id, ad_frequency, and seasonality, had no missing data.</p>
<p>I also observed a pattern in the missingness, suggesting that the data were missing not completely at random.</p>
</section>
<section id="impute-missing-values" class="level3">
<h3 class="anchored" data-anchor-id="impute-missing-values">Impute missing values</h3>
<p>To address missing values, several imputation strategies were tested:</p>
<p>1.Median imputation was used for numerical variables and mode imputation for categorical variables. I used this method for most of my predictions due to its simplicity;</p>
<p>2.MICE imputation was used for numerical variables after confirming that missingness was less than 20%. For categorical variables, missing values were replaced with ‘unknown’. I tried this technique for a polynomial regression model as an attempt to use a more sophisticated method; I also used it for a random forest, but compared to the simplest technique, the random forest performed better.</p>
<p>3.Vtreat was used for my best submission according to the public score (0.07523). It is tipically used for XGBoost models. With this technique, missing values are automatically imputed without any loss of information.</p>
</section>
<section id="initial-data-exploration" class="level3">
<h3 class="anchored" data-anchor-id="initial-data-exploration">Initial Data Exploration</h3>
<p>After imputing missing values, exploratory analysis of variables was conducted.I observed that the target variable, CTR, had a skewed distribution. For this reason, I tried transforming CTR into log(CTR), which improved the results for the linear regression model. However, for random forest and XGBoost, the results were worse, coming to the conclusion that just in the linear regression a variable transformation can generate an upgrade in this context.</p>
<p>Additionally, several predictors appeared to have a polynomial rather than a linear relationship with CTR:</p>
<ul>
<li><p>targeting_score</p></li>
<li><p>visual_appeal</p></li>
<li><p>cta_strength</p></li>
<li><p>headline_lenght</p></li>
</ul>
</section>
<section id="correlation-and-multicollinearity-check" class="level3">
<h3 class="anchored" data-anchor-id="correlation-and-multicollinearity-check">Correlation and Multicollinearity Check</h3>
<p>Then, I checked the correlation matrix among numeric variables and visualized it with a heatmap. It was clear that the strongest predictor for CTR was visual_appeal, always present in my models.</p>
<p>I also checked the VIF to assess whether there were multicollinearity issues, but found none.</p>
</section>
</section>
<section id="data-processing" class="level2">
<h2 class="anchored" data-anchor-id="data-processing">Data processing</h2>
<p>Feature engineering steps included aligning categorical levels between the two datasets to ensure consistency when comparing categorical predictors and creating dummy variables for categorical predictors. This was automatically done by vtreat in case of my best model, which code is provided below.</p>
<p>As the variables had different ranges, I considered whether it was better to standardize them. After standardizing the variables, I consistently improved the linear regression model. I concluded that standardization is important for linear regression, while other models, such as regression trees, random forest, and XGBoost, do not require it.</p>
</section>
<section id="variables-selection" class="level2">
<h2 class="anchored" data-anchor-id="variables-selection">Variables selection</h2>
<p>As learned during the lesson, theory is important when it comes to selecting variables. I went through an article on Internet, and I found that headline, type of device utilized are important predictors. I kept that in mind for my analysis.</p>
<p>On top of that, to select the most appropriate set of predictors, multiple feature selection techniques were explored.</p>
<p>The simplest was filtering. Indeed, I calculated the correlations and kept the most important six predictors for CTR and with this method, I obtained the best prediction according to Kaggle.</p>
<p>The method I used most in my models was stepwise regression, applied using the stepAIC() function from the MASS package:</p>
<ul>
<li><p>Forward selection, backward elimination, and both-direction stepwise selection were performed based on the Akaike Information Criterion (AIC).</p></li>
<li><p>In addition, selection based on the Bayesian Information Criterion (BIC) was conducted by adjusting the penalty term (<code>k = log(n)</code>).</p></li>
<li><p>To complement this approach, subset selection was conducted using the <code>regsubsets()</code> function from the <code>leaps</code> package.<br>
This method evaluated all possible models up to ten variables, comparing models based on Mallows’ Cp and adjusted R² statistics.</p></li>
</ul>
<p>Finally, results from the stepwise and subset selection procedures were compared. Models were assessed based on AIC, BIC, Mallows’ Cp, and adjusted R², and the final model (based on BIC) was chosen by balancing predictive accuracy with model simplicity. In the end, the variables selected with these method were:</p>
<ul>
<li>targeting_score<br>
visual_appeal<br>
headline_length<br>
cta_strength<br>
ad_format.Video<br>
location.Northeast<br>
time_of_day.Morning<br>
</li>
</ul>
<p>As can be seen, headline_length and also the format of the ad appeared in the selected variables, as suggested by my researches.</p>
</section>
<section id="modeling-and-analysis" class="level2">
<h2 class="anchored" data-anchor-id="modeling-and-analysis">Modeling and Analysis</h2>
<p>When it came to modeling, I followed a general strategy:</p>
<ul>
<li><p>Used RMSE from the LM model with just the intercept as my first benchmark</p></li>
<li><p>Tried several regression models that we learned</p></li>
<li><p>Tuning hyperparameters</p></li>
<li><p>Set up a cross validation</p></li>
<li><p>Optimize RMSE</p></li>
</ul>
<p>My initial strategy did not take feature selection into account. I learned from my mistakes how important this step is; indeed, when I included feature selection in my models, I made significant progress.</p>
<p>Kaggle recognized as the best model an XGBoost model tuned with variable selection by filtering the most important predictors, according to their correlation with CTR. However, my best model, according to public private score, is an XGBoost model tuned without variables selection. I come to conclusion that this model worked better without variables selection in my experience; and this is in generally how XGBoost works, it automatically selects the important variables. However, to strengthen this conclusion, further testing with alternative feature selection strategies would have been beneficial.</p>
</section>
<section id="models-explored" class="level2">
<h2 class="anchored" data-anchor-id="models-explored">Models explored</h2>
<p>Initially, I started with a simple linear regression model, following the initial approach to regression proposed during the course, to establish a performance benchmark.<br>
Subsequently, I experimented with more complex models, including</p>
<ul>
<li><p>Multiple linear regression: The best result I obtained was when I transformed polynomial variables, reaching a public score of 0.09988 (private score: 0.08325), compared to the initial simple linear model with just the intercept as predictor (public score: 0.18014, private score: 0.0222954). I learned how important it is to examine the distribution of the variables. I also ran Lasso and Ridge regressions, but the improvement was minimal, so I focused on regression trees.</p></li>
<li><p>Regression trees and tuned regression trees: I improved the results with tuned regression trees, reaching a public score of 0.08768 on the leaderboard (private score: 0.10427). Still, my model was overfitting because the RMSE on the train set was much lower than that on the test set; the difference between the public and private scores also reflected this. I incorporated CV techniques to ensure more stable results and I tried other models.</p></li>
<li><p>Random forest, random forest tuned: I did a big step ahead with selecting variables according to the BIC method that I explained above: I learned how important is to select important features, reaching on the leaderboard public score of 0.07521. Still, my model had overfitting problems (I got an RMSE on the train set equal to 0.04116892 and in the holdout set equal to 0.1632433), so I came back analyzing the methods to impute missing values, and also exploring variables distributions.</p></li>
<li><p>and XGBoost. In the early stages, I did not perform any variable selection and evaluated the models using all available features. However, after encountering a plateau in performance improvements, I revisited the theoretical background and implemented a simple feature selection strategy. I analyzed again the correlations between the predictors and the target variable (CTR), selecting the six most highly correlated variables (in absolute terms) and this is the best model selected by Kaggle:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Predictor</th>
<th>Correlation value with CTR</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><pre><code>visual_appeal</code></pre></td>
<td><pre><code>0.537941160</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>targeting_score</code></pre></td>
<td><pre><code>0.325348336</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code> cta_strength</code></pre></td>
<td><pre><code>0.162673409</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>headline_length</code></pre></td>
<td><pre><code>0.126800982</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>ad_formatVideo</code></pre></td>
<td><pre><code>0.111566336</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>ad_formatText</code></pre></td>
<td><pre><code>0.109721898</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>body_text_length</code></pre></td>
<td><pre><code>0.084341053</code></pre></td>
</tr>
</tbody>
</table></li>
<li><p>Tuning a simple random forest model already provided improvements compared to the earlier, untuned XGBoost model, highlighting the importance of careful tuning hyperparameters.</p></li>
<li><p>After refining the feature set, I proceeded to tune the hyperparameters of the XGBoost model, which further improved predictive performance, anyway even if I tried in many ways to prevent overfitting, still, my model was overfitting:</p>
<p>RMSE TRAIN</p>
<pre><code>0.05530341 </code></pre>
<p>RMSE TEST</p>
<pre><code>0.1555509 </code></pre></li>
<li><p>In the end, my best model, according to the private and public score is an XGBoost model, without feature selection, with imputed missing values using vtreat, tuned with hyperparameters that can be seen in the code chunk. The hyperparameter ranges selected for tuning were based on typical best practices for XGBoost models.<br>
The hyperparameters used for tuning were chosen based on standard recommendations for XGBoost.<br>
I set the learning rate (eta) to 0.1 to balance training speed and model stability.<br>
The tree depth (max_depth = 4) was chosen to avoid overfitting due to overly complex trees.<br>
Subsampling parameters (subsample = 0.6 and colsample_bytree = 0.6) were used to introduce randomness and improve generalization.<br>
These settings were evaluated using cross-validation to identify the optimal number of boosting rounds. This tuning process helped optimize the model while reducing the risk of overfitting. I obtained the following RMSE:</p>
<p>RMSE Train 0.07596</p>
<p>RMSE Test 0.07214</p></li>
</ul>
<p>Looking at the RMSE, this model is more equilibrated than the one selected by Kaggle, demonstrating a almost null overfitting. Observing also the public and private score, I come to the conclusion that this XGBoost model is the best model I performed.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>This experience taught me several key lessons:</p>
<ul>
<li><p>Careful <strong>feature selection</strong> could significantly improve model performance, but it is important to try different feature selection methods, and don’t be strict to one.</p></li>
<li><p>Careful about preventing <strong>overfitting</strong>. I utilized CV techniques, and hyperparameters, but I believe that I had to go further with this to prevent overfitting.</p></li>
<li><p><strong>Model tuning</strong> (hyperparameter optimization) is critical: tuned models consistently outperformed non-tuned models. When it comes to XGBoost model, it is more difficult to find the right hyperparameter, more experience in my case in needed, but finding the optimal rounds, was important to prevent overfitting.</p></li>
<li><p>There is no “one-size-fits-all” method; different techniques must be tested and validated based on the specific context and data characteristics.</p></li>
<li><p>Revisiting “<strong>theoretical knowledge”</strong> help ensure that selected variables made sense and resonated with domain understanding.</p></li>
<li><p>Overall, this iterative approach of modeling, diagnosing, feature engineering, and tuning proved crucial for achieving my best results.</p></li>
</ul>
</section>
<section id="best-model-according-to-public-score" class="level2">
<h2 class="anchored" data-anchor-id="best-model-according-to-public-score">Best model according to public score</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load necessary packages</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(caret)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(vtreat)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(xgboost)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Set working directory and load data</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="fu">setwd</span>(<span class="st">"C:</span><span class="sc">\\</span><span class="st">Users</span><span class="sc">\\</span><span class="st">huawei</span><span class="sc">\\</span><span class="st">Desktop</span><span class="sc">\\</span><span class="st">APANFRAMEWORK</span><span class="sc">\\</span><span class="st">my_PAC_project</span><span class="sc">\\</span><span class="st">Data"</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>analysis_data <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"analysis_data.csv"</span>, <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>scoring_data  <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"scoring_data.csv"</span>, <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Save a copy of original data</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>analysis_data_original <span class="ot">&lt;-</span> analysis_data</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Split data into train and test sets</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1031</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>train_index <span class="ot">&lt;-</span> <span class="fu">createDataPartition</span>(analysis_data<span class="sc">$</span>CTR, <span class="at">p =</span> <span class="fl">0.7</span>, <span class="at">list =</span> <span class="cn">FALSE</span>, <span class="at">groups =</span> <span class="dv">200</span>)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>train_data <span class="ot">&lt;-</span> analysis_data[train_index, ]</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>test_data <span class="ot">&lt;-</span> analysis_data[<span class="sc">-</span>train_index, ]</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Data preprocessing using vtreat</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>treatment_plan <span class="ot">&lt;-</span> <span class="fu">designTreatmentsZ</span>(<span class="at">dframe =</span> train_data, </span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">varlist =</span> <span class="fu">setdiff</span>(<span class="fu">names</span>(train_data), <span class="fu">c</span>(<span class="st">"id"</span>, <span class="st">"CTR"</span>)))</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>newvars <span class="ot">&lt;-</span> treatment_plan<span class="sc">$</span>scoreFrame[treatment_plan<span class="sc">$</span>scoreFrame<span class="sc">$</span>code <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">'clean'</span>, <span class="st">'lev'</span>), <span class="st">'varName'</span>]</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>train_input <span class="ot">&lt;-</span> <span class="fu">prepare</span>(<span class="at">treatmentplan =</span> treatment_plan, <span class="at">dframe =</span> train_data, <span class="at">varRestriction =</span> newvars)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>test_input <span class="ot">&lt;-</span> <span class="fu">prepare</span>(<span class="at">treatmentplan =</span> treatment_plan, <span class="at">dframe =</span> test_data, <span class="at">varRestriction =</span> newvars)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="co">#Applyed Cross Validation for my XGBoost model, with hyperparameters chosen as explained in this report</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>cv <span class="ot">&lt;-</span> <span class="fu">xgb.cv</span>(</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">as.matrix</span>(train_input), </span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>  <span class="at">label =</span> train_data<span class="sc">$</span>CTR,</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>  <span class="at">nrounds =</span> <span class="dv">10000</span>,</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  <span class="at">eta =</span> <span class="fl">0.1</span>,</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>  <span class="at">max_depth =</span> <span class="dv">4</span>,</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_child_weight =</span> <span class="dv">3</span>,</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>  <span class="at">subsample =</span> <span class="fl">0.6</span>,</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>  <span class="at">colsample_bytree =</span> <span class="fl">0.6</span>,</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>  <span class="at">lambda =</span> <span class="dv">1</span>,</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>  <span class="at">early_stopping_rounds =</span> <span class="dv">100</span>,</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>  <span class="at">nfold =</span> <span class="dv">5</span>,</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>  <span class="at">metrics =</span> <span class="st">'rmse'</span>,</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>  <span class="at">verbose =</span> <span class="dv">0</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Train final XGBoost model using best number of rounds, to prevent overfitting</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>optimal_nrounds <span class="ot">&lt;-</span> cv<span class="sc">$</span>best_iteration</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>xgboost_model <span class="ot">&lt;-</span> <span class="fu">xgboost</span>(</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">as.matrix</span>(train_input),</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>  <span class="at">label =</span> train_data<span class="sc">$</span>CTR,</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>  <span class="at">nrounds =</span> optimal_nrounds,</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>  <span class="at">eta =</span> <span class="fl">0.1</span>,</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>  <span class="at">max_depth =</span> <span class="dv">4</span>,</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>  <span class="at">min_child_weight =</span> <span class="dv">3</span>,</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>  <span class="at">subsample =</span> <span class="fl">0.6</span>,</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>  <span class="at">colsample_bytree =</span> <span class="fl">0.6</span>,</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>  <span class="at">lambda =</span> <span class="dv">1</span>,</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>  <span class="at">verbose =</span> <span class="dv">0</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Predictions and RMSE on training set</span></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>pred_train <span class="ot">&lt;-</span> <span class="fu">predict</span>(xgboost_model, <span class="at">newdata =</span> <span class="fu">as.matrix</span>(train_input))</span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>rmse_train <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((pred_train <span class="sc">-</span> train_data<span class="sc">$</span>CTR)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Train RMSE:"</span>, rmse_train))</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a><span class="co"># Predictions and RMSE on test set</span></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a>pred_test <span class="ot">&lt;-</span> <span class="fu">predict</span>(xgboost_model, <span class="at">newdata =</span> <span class="fu">as.matrix</span>(test_input))</span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>rmse_test <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((pred_test <span class="sc">-</span> test_data<span class="sc">$</span>CTR)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Test RMSE:"</span>, rmse_test))</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Final RMSE from cross-validation</span></span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>final_rmse_cv <span class="ot">&lt;-</span> cv<span class="sc">$</span>evaluation_log[cv<span class="sc">$</span>best_iteration, <span class="st">"test_rmse_mean"</span>]</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Final RMSE from CV:"</span>, final_rmse_cv))</span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Feature importance plot </span></span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a>importance <span class="ot">&lt;-</span> <span class="fu">xgb.importance</span>(<span class="at">feature_names =</span> <span class="fu">colnames</span>(train_input), <span class="at">model =</span> xgboost_model)</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a><span class="fu">xgb.plot.importance</span>(<span class="at">importance_matrix =</span> importance)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Schaller, T. (n.d.). <em>What is click-through rate (CTR) and why it matters</em>. Retrieved from <a href="https://strikesocial.com/blog/click-through-rate/" class="uri">https://strikesocial.com/blog/click-through-rate/</a> SEO Business. (n.d.).</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>